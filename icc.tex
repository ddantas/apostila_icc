\documentclass{book}

\pagenumbering{roman} 
\pagestyle{empty}

% Notas de aula
%
% Template criado em 24/9/2013
% Daniel Oliveira Dantas
%
% Ctrl+x 8 , c = ç

\usepackage[utf8]{inputenc}
\usepackage[english, brazil]{babel}

\usepackage{listings}
\lstset{
  language=C,                % choose the language of the code
  numbers=none,                   % where to put the line-numbers
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=10pt,                  % how far the line-numbers are from the code
  %backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  title=\lstname,                 % show the filename of files included with \lstinputlisting;
}

%formatacao

\newcommand{\TAB}{{\hspace*{1cm}}}
\newcommand{\NEWLINE}{~\\}
\newcommand{\BV}{\begin{verbatim}}
\newcommand{\EV}{\end{verbatim}}

%tipos de dados

\newcommand{\VOID}{{\tt void}}
\newcommand{\CHAR}{{\tt char}}
\newcommand{\INT}{{\tt int}}
\newcommand{\FLOAT}{{\tt float}}
\newcommand{\DOUBLE}{{\tt double}}

\newcommand{\LONGINT}{{\tt long int}}

%operadores

\newcommand{\AND}{{\tt \&\&}}
\newcommand{\OR}{{\tt ||}}

\newcommand{\LNOT}{{\tt \~{}}}
\newcommand{\LAND}{{\tt \&}}
\newcommand{\LOR}{{\tt |}}
\newcommand{\LXOR}{{\tt \^{}}}

%palavras reservadas

\newcommand{\IF}{{\tt if}}
\newcommand{\ELSE}{{\tt else}}

\newcommand{\SWITCH}{{\tt switch}}
\newcommand{\CASE}{{\tt case}}

\newcommand{\FOR}{{\tt for}}
\newcommand{\WHILE}{{\tt while}}

\newcommand{\BREAK}{{\tt break}}

\newcommand{\TRUE}{{\tt true}}
\newcommand{\FALSE}{{\tt false}}

\newcommand{\MAIN}{{\tt main}}

\newcommand{\SIZEOF}{{\tt sizeof}}

% funcoes

\newcommand{\SIN}{{\tt sin}}
\newcommand{\COS}{{\tt cos}}
\newcommand{\TAN}{{\tt tan}}
\newcommand{\LOG}{{\tt log}}

\newcommand{\PRINTF}{{\tt printf}}
\newcommand{\SCANF}{{\tt scanf}}

\newcommand{\SPRINTF}{{\tt sprintf}}
\newcommand{\SSCANF}{{\tt sscanf}}

\newcommand{\FPRINTF}{{\tt fprintf}}
\newcommand{\FSCANF}{{\tt fscanf}}

\newcommand{\GETS}{{\tt gets}}
\newcommand{\FGETS}{{\tt fgets}}

\newcommand{\FOPEN}{{\tt fopen}}
\newcommand{\FCLOSE}{{\tt fclose}}

\newcommand{\SYSTEM}{{\tt system}}

%renewcommand

\renewcommand\chaptername{Capítulo}
\renewcommand\lstlistingname{Listagem}



\title{Notas de aula de Introdução à Ciência da Computação}
\author{Daniel Oliveira Dantas}
\date{6 de novembro de 2013}
\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Índice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\pagestyle{plain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Capítulo: Introdução ao C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introdução ao C}

\setcounter{page}{1}    % set page to 1 again to start arabic count
\pagenumbering{arabic}

O C é uma linguagem {\it case sensitive}, compilada, com tipagem estática e fraca. 
{\it Case sensitive} porque letras maiúsculas são consideradas diferentes de minúsculas. Seu código não roda interativamente como nas linguagens interpretadas. Deve ser compilado, ou seja, gerar código executável antes de rodar. Se diz que o C tem tipagem estática pois o tipo de uma variável, uma vez definido, não muda mais. Se diz que C tem tipagem fraca pois é possível realizar operações entre variáveis de tipos diferentes, como somar inteiros e reais.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Palavras reservadas

\section{Palavras reservadas}

\begin{itemize}

\item Palavras reservadas ou palavras chave: são palavras que não podem ser usadas para nomear variáveis ou funções criadas pelo usuário.

{\tt
\begin{tabular}{lll}
char     & void     & for     \\
double   & true     & if      \\
float    & false    & else    \\
int      & switch   & typedef \\
long     & case     & struct  \\
short    & default  & return  \\
signed   & break    & main    \\
unsigned & while    & sizeof  \\
\end{tabular}
}


\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Um programa em C mínimo

\section{Um programa em C mínimo}


\begin{itemize}

\item Um programa em C mínimo: este programa não faz nada, simplesmente declara uma função \MAIN\ vazia. A função \MAIN\ é o ponto de entrada de qualquer projeto em C, ou seja, por onde o programa começa a execução. Neste exemplo não há nenhuma instrução dentro da \MAIN.

\begin{lstlisting}
int main(void)
{
}
\end{lstlisting}


\item Outro programa em C: este programa simplesmente imprime uma mensagem na tela através de uma chamada à função \PRINTF. Para usar \PRINTF, é necessário incluir o arquivo de cabeçalho {\tt stdio.h}.

\begin{lstlisting}
#include <stdio.h>
int main(void)
{
    printf("Hello world!\n");
}
\end{lstlisting}


\item Ainda outro programa em C: como no exemplo anterior, imprime uma mensagem na tela. Além disso, espera o usuário pressionar uma tecla antes de terminar a execução através de uma chamada de sistema a um comando chamado {\tt pause}. Essa chamada é feita através da função \SYSTEM. Para usar \SYSTEM, é necessário incluir o arquivo de cabeçalho {\tt cstdlib}.

\begin{lstlisting}
#include <stdio.h>
#include <cstdlib>
int main(void)
{
    printf("Hello world!\n");
    system("pause");
}
\end{lstlisting}

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Programando em C

\section{Programando em C}

Para programar em C é necessário um compilador. Se seu sistema operacional for Windows, instale o Orwell Dev-C++, conhecido como {\it devcpp}, disponível em:

{\tt http://sourceforge.net/projects/orwelldevcpp/}

Se seu sistema operacional for Linux, instale o gcc rodando o comando

{\tt sudo apt-get install gcc}

\begin{itemize}

\item Como criar um programa em C

\subitem 1 - Editar o código fonte e salvar em um arquivo com extensão cpp.
\subitem 2 - Compilar o código fonte usando um compilador.
\subitem 3 - Rodar o programa.

\item Usando o devcpp: o devcpp é um ambiente integrado de programação, com editor e compilador na mesma aplicação.

\subitem 1 - Criar um novo {\it source file} com ctrl + n.
\subitem 2 - Editar e salvar o arquivo com extensão cpp.
\subitem 3 - Pressionar F9 para compilar e rodar.
\subitem 4 - Ler as mensagens do compilador e corrigir os erros.
\subitem 5 - {\it Go to} 3.

\item Usando o gcc: o gcc é um compilador de linha de comando.

\subitem 1 - Criar um novo {\it source file} com um editor de texto como o emacs.
\subitem 2 - Editar e salvar o arquivo com extensão cpp.
\subitem 3 - Compilar usando o gcc. Antes de rodar a linha de comando abaixo, substitua o conteúdo entre {\tt <>} pelos nomes dos arquivos.

{\tt gcc <nome\_arq\_fonte.cpp> -o <nome\_arq\_executável>}

\subitem 4 - Ler as mensagens do compilador e corrigir os erros de compilação.
\subitem 5 - Chamar o executável caso tenha compilado e corrigir os erros de lógica.
\subitem 6 - {\it Go to} 3.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Literais

\section{Literais}
\label{sec:lit}

Literais são valores com os quais podemos trabalhar. Podem ser de diversos tipos:

\nobreakspace

{\tt
\begin{tabular}{llll}
Números inteiros:        & 0                     & Números reais:    & 2.0       \\
                         & -1                    &                   & 3.1415    \\
                         & 333                   &                   & -1000.0   \\
\\
Inteiros hexadecimais:   & 0xff                  & Inteiros octais:  & 077       \\
                         & 0x002a                &                   & 06        \\
                         & 0xd                   &                   & 02342     \\
\\
Caracteres:              & 'a'                   & Strings:          & "Hello world"       \\
                         & '4'                   &                   & "bom dia"           \\
                         & '\textbackslash n'    &                   & "Idade = \%d anos"   \\
\\
Valores booleano:        & true                  &                   &                      \\
                         & false                 &                   &                      \\
\end{tabular}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Chamada de funções

\section{Chamada de funções}

\begin{itemize}

\item Funções são trechos de código encapsulados que executam alguma operação.
\item Funções são chamadas pelo nome.
\item Recebem zero ou mais parâmetros entre parênteses. O número de parâmetros é definido na sua criação e pode ser constante 
(as funções {\tt sin}, {\tt cos}, {\tt log} recebem um parâmetro; 
a função {\tt pow} recebe dois parâmetros)
ou variável (\PRINTF\ recebe um ou mais parâmetros).
\item Podem retornar um valor de algum tipo de dado. Esse tipo (real, inteiro, caracter etc) é definido no momento da sua criação. O valor retornado pode mudar dependendo dos parâmetros que a função recebe ao ser chamada.
\item Podem também não retornar nada. São as funções de tipo {\tt void}.

\item Exemplos de chamadas:

\begin{lstlisting}
printf("Hello\n");
printf("O mundo termina no ano de %d\n", 2012);
sin(1.0);
pow(2.0, 3.0);
printf("O seno de pi/2 eh %f\n", sin(3.14/2.0));
\end{lstlisting}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: A biblioteca de funções matemáticas

\section{A biblioteca de funções matemáticas}

Para usá-la, adicione a linha seguinte ao início do código:

\begin{lstlisting}
#include <math.h>
\end{lstlisting}

\begin{itemize}

\item Caso esteja usando Linux, adicionar a opção {\tt -lm} à linha de comando de chamada ao gcc.

\item Contém funções como

{\tt
\begin{tabular}{lll}
sin      & cos      & tan     \\
asin     & acos     & atan    \\
log      & log10    & pow     \\
ceil     & floor    & fabs    \\
\end{tabular}
}

\item Contém constantes como

{\tt
\begin{tabular}{lll}
M\_PI    & M\_E     &         \\
\end{tabular}
}

\item Abaixo está um exemplo de programa que usa essa biblioteca. O programa imprime uma mensagem com o valor do seno de de pi/4 através de uma chamada a \PRINTF, e espera o usuário pressionar uma tecla antes de finalizar.

\begin{lstlisting}
#include <stdio.h>
#include <cstdlib>
#include <math.h>
int main(void)
{
    printf("O seno de pi/4 eh %f\n", sin(3.14/4.0));
    system("pause");
}
\end{lstlisting}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Comentários

\section{Comentários}

Comentários são textos ignorados pelo compilador. Dentro de um comentário é possível escrever qualquer coisa, sem risco de erros de compilação. Em C existem dois tipos de comentário:

\begin{itemize}

\item Comentários de uma linha: começa com {\tt //} e vai até o final da linha.
\item Comentários de múltiplas linhas: começa com {\tt /*} e termina com {\tt */}.

\item Exemplo de programa com comentários.

\begin{lstlisting}
/* 
Programa que imprime o valor do seno
de 45 graus, ou pi/4.
*/
#include <stdio.h> // biblioteca do printf
#include <cstdlib> // biblioteca do system
#include <math.h>  // biblioteca do sin
int main(void)
{
    printf("O seno de pi/4 eh %f\n", sin(3.14/4.0));
    system("pause");
}
\end{lstlisting}


\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Identificadores

\section{Identificadores}
\label{sec:ident}

Identificadores são os nomes de variáveis, funções, constantes e outros objetos, tanto os criados pelo usuário quanto os contidos em bibliotecas.

\begin{itemize}
\item O primeiro caracter pode ser letra ou sublinhado
\item Os demais caracteres podem ser letras, dígitos ou sublinhado.
\item Não pode ser igual a nenhuma palavra reservada.
\item Exemplos:

{\tt
\begin{tabular}{llll}
Corretos:           & \_ABC                 & Incorretos:     & 123       \\
                    & contador              &                 & i+1       \\
                    & i                     &                 & a!        \\
                    & x2                    &                 & r\$       \\
\end{tabular}
}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Variáveis

\section{Variáveis}

Variáveis são posições de memória com um nome, usadas para armazenar valores. Os valores armazenados podem ser modificados a qualquer momento.

\begin{itemize}
\item O nome de uma variável deve ser um identificador válido, como descrito na Seção \ref{sec:ident}.
\item Sua declaração e inicialização devem aparecer no código antes de seu primeiro uso.
\item A declaração de uma variável é onde definimos seu tipo e seu identificador, isto é, seu nome.
\item A inicialização de uma variável é onde atribuímos a ela algum valor.
\item A declaração de uma variável tem o seguinte formato:

{\tt <tipo de dados> <identificador>;}

\item Exemplos de declarações de variáveis:
\begin{lstlisting}
int x;
int i;
float f;
char c;
unsigned int file_size;
unsigned char idade;
unsigned short int ano;
double p1;
long long int n;
long double value;
\end{lstlisting}


\item Variáveis podem ser:
\subitem Locais, quando declaradas dentro de uma função.
\subitem Globais, quando declaradas fora de funções.
\subitem Parâmetros, quando declaradas na lista de parâmetros da definição de uma função.

\item Variáveis locais e globais podem ser inicializadas, ou seja, receber algum valor, no momento de sua declaração. O formato de uma declaração com inicialização é o seguinte:

{\tt <tipo de dados> <identificador> = <valor>;}

Lembrando que identificador é o nome. O valor pode ser um literal, como descrito na Seção~\ref{sec:lit}, outra variável, uma chamada de função que retorna algum valor, ou mesmo uma expressão matemática.

\item Exemplos de declarações de variáveis com inicialização:
\begin{lstlisting}
int x = 1;
int i = 0;
float e = 2.7;
char c = 'a';
double p = sin(M_PI/4.0);
double p2 = p;
double p_dup = 2.0 * p;
\end{lstlisting}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Constantes

\section{Constantes}

Como variáveis, constantes são posições de memória que armazenam algum valor. Porém ao contrário de variáveis, o valor não pode ser modificado.

\begin{itemize}

\item A declaração de uma constante tem o seguinte formato:

{\tt const <tipo de dados> <identificador> = <valor>;}

\item Exemplos de declarações de constantes:
\begin{lstlisting}
const long int c = 299792458;
const float pi = 3.141592653589793238462;
const float G = 6.67428E-11;
const double h = 6.62606896E-34;
\end{lstlisting}

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Tipos de dados

\section{Tipos de dados}

Em um computador digital, todo e qualquer dado é armazenado em forma de bits. O conteúdo de uma posição de memória pode ser interpretado como um número inteiro, real ou até mesmo uma string. Portanto, para que um dado seja interpretado corretamente, é necessário associar a esse dado o seu tipo. Na linguagem C os tipos mais importantes são:

\begin{itemize}
\item {\tt int}: valor inteiro. Normalmente ocupa 4 bytes, sendo capaz de representar inteiros de -2147483648 a 2147483647.
\item {\tt float}: valor real. Normalmente ocupa 4 bytes, sendo capaz de representar valores reais com cerca de 8 dígitos significativos.
\item {\tt double}: valor real. Normalmente ocupa 8 bytes, sendo capaz de representar valores reais com cerca de 16 dígitos significativos.
\item {\tt char}: valor inteiro pequeno ou caracter. Ocupa 1 byte, sendo capaz de representar inteiros de -128 a 127.
\item {\tt bool}: valor lógico. Pode ser {\tt true} ou {\tt false}.

\item {\tt void}: tipo vazio. Usado para declarar funções que não retornam valor ou ponteiros sem tipo associado.
\end{itemize}

Alguns tipos de dados podem ser alterados por modificadores:

\begin{itemize}
\item {\tt unsigned}: pode modificar os tipos {\tt int} e {\tt char}. Uma variável {\tt unsigned} é sempre positiva, e pode representar valores duas vezes maiores que sua correspondente {\tt signed}
\item {\tt signed}: pode modificar os tipos {\tt int} e {\tt char}. 
Por padrão toda variável {\tt int} e {\tt char} é {\tt signed}, ou seja, com sinal.
\item {\tt short}: pode modificar o tipo {\tt int}, diminuindo sua capacidade. Normalmente, em máquinas de 64 bits, um short int ocupa 2 bytes.
\item {\tt long}: pode modificar os tipos {\tt int} e {\tt double}, aumentando sua capacidade. Normalmente, em máquinas de 64 bits, um long int ocupa 8 bytes e um long double, 16 bytes.

\end{itemize}

Para descobrir quanto espaço ocupa uma variável de um certo tipo de dados, usar o operador unário \SIZEOF. \SIZEOF\ pode ser usado com tipos de dados ou com variáveis. No primeiro caso, o uso de parênteses é obrigatório, e no segundo, é opcional. Observe o exemplo abaixo.

\begin{lstlisting}
#include <stdio.h>
#include <cstdlib>
int main(void)
{
    char C;
    printf("Um int ocupa %ld bytes\n", sizeof(int));
    printf("A variavel C ocupa %ld bytes\n", sizeof(C));
    system("pause");
}
\end{lstlisting}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Expressões numéricas

\section{Expressões numéricas}
\label{sec:expr}

Expressões numéricas são compostas por operadores e operandos. Os operandos podem ser literais, funções que retornam algum valor, variáveis, constantes, ou mesmo outras expressões. Os operadores podem ser de atribuição, de comparação, aritméticos, lógicos ou bit a bit.

\begin{itemize}
\item Uma expressão elementar contém apenas um operando:
\subitem {\tt <literal>}
\subitem {\tt <função que retorna valor>}
\subitem {\tt <variável>}
\subitem {\tt <constante>}

\item Exemplos de expressões elementares:
\begin{lstlisting}
10
sin(M_PI)
x
M_PI
\end{lstlisting}

\item Uma expressão composta pode conter vários operadores e operandos:
\subitem {\tt ( <expressão> <operador binário> <expressão> )}
\subitem {\tt ( <operador unário> <expressão> )}

\item Exemplos de expressões compostas:
\begin{lstlisting}
2 + 2
-1
x = 10
sin(M_PI) + 1.0
y = (3 + x)
n = 2 * (3 + i)
\end{lstlisting}


\end{itemize}

\subsection{O operador de atribuição \emph{=}}

É usado para atribuir um valor a uma variável. É importante salientar que, antes de usar uma variável, ela deve ser inicializada, ou seja, algum valor deve ser atribuído a essa variável. Uma variável não inicializada pode conter um valor imprevisível.

\begin{itemize}
\item A forma geral de uma atribuição é a seguinte:

{\tt <identificador da variável> = <expressão>;}

Onde é claro que {\tt expressão} pode ser elementar, como um valor literal, outra variável, uma constante, uma chamada a função; ou composta, como uma operação aritmética, lógica etc.

\item Exemplos de atribuições:
\begin{lstlisting}
n = 10;
m = n;
y = - (3 + x);
n = 3 * (4 + i);
\end{lstlisting}

\end{itemize}

\subsection{Operadores aritméticos}

Expressões com operadores aritméticos retornam valores numéricos, inteiros ou reais.

~\\

{\tt
\begin{tabular}{|l|llll|}
\hline
Precedência:        &    &    &     &                                    \\
maior               & ++ & -- &     & (incremento e decremento unário)   \\
                    & -  &    &     & (menos unário)                     \\
                    & *  & /  & \%  & (multiplicaćão, divisão e módulo)  \\
menor               & +  & -  &     & (soma e subtração)                 \\
\hline
\end{tabular}
}

\begin{itemize}

\item Operadores de maior precedência são avaliados antes dos de menor precedência.
\item Operadores com mesmo nível de precedência são avaliados da esquerda para a direita.
\item É possível usar parênteses para modificar a ordem das operações
\item {\tt i++} é o mesmo que {\tt i = i + 1}.
\item {\tt i--} é o mesmo que {\tt i = i - 1}.

\item Nos exemplos abaixo, que valor é atribuído à variável à esquerda do operador {\tt =}?

\begin{lstlisting}
a = 2 * 3 + 1;
b = 1 + 2 * 3;
c = 10 / 2 * 5;
d = 10 % 3;
e = 2 * 10 % 4;
f = 3 * (2 + 1);
g = 2;
h = 3 * ++g;
i = 3 * g++;
\end{lstlisting}

\end{itemize}

\subsection{Operadores lógicos e de comparação}

Expressões com operadores lógicos ou de comparação retornam valores do tipo {\tt bool}, ou seja, {\tt true} ou {\tt false}.

~\\

{\tt
\begin{tabular}{|l|lllll|}
\hline
Precedência:        &      &    &    &    &                                    \\
maior               & !    &    &    &    & (negação lógica)                   \\
                    & >    & >= & <  & <= & (desigualdade)                     \\
                    & ==   & != &    &    & (igualdade e diferença)            \\
                    & \&\& &    &    &    & (and lógico)                       \\
menor               & ||   &    &    &    & (or lógico)                        \\
\hline
\end{tabular}
}

\begin{itemize}

\item Nos exemplos abaixo, que valor é atribuído à variável à esquerda do operador {\tt =}?

\begin{lstlisting}
a = 1 < 2;
b = true || false;
c = true && false;
d = 1 < 2 || 4 < 2;
e = 1 < 2 && 4 < 2;
f = 1 < 1;
g = !(3 < 2);
e = 3 == 4;
e = 3 != 4;
\end{lstlisting}

\item Para testar se o valor de uma variável está em um certo intervalo, a construção é a seguinte: 

\begin{lstlisting}
f > 0 && f < 1
\end{lstlisting}

para testar se f está entre 0 e 1. Jamais omitir o {\tt \&\&} como na expressão INCORRETA abaixo:

\begin{lstlisting}
0 < f < 1
\end{lstlisting}

\end{itemize}

\subsection{Operadores bit a bit}

Operam sobre o valor binário de uma variável. A variável só pode ser do tipo \INT, \CHAR\ ou suas variantes.

~\\

{\tt
\begin{tabular}{|l|llll|}
\hline
Precedência:        &       &    &     &                                    \\
maior               & \LNOT &    &     & (complemento de um)                \\
                    & <<    & >> &     & (shift left e shift right)         \\
                    & \LAND &    &     & (and binário)                      \\
                    & \LXOR &    &     & (xor binário)                      \\
menor               & \LOR  &    &     & (or binário)                       \\
\hline
\end{tabular}
}


\begin{itemize}

\item Nos exemplos abaixo, que valor é atribuído à variável à esquerda do operador {\tt =}?

\begin{lstlisting}
a = 3 | 1;
b = 1 >> 1;
c = 1 << 1;
d = 1 << 2;
e = 5 ^ 3;
f = ~ 0;
\end{lstlisting}

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Capítulo: Controle de fluxo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Controle de fluxo}

Um programa de computador é uma sequência de instruções. Normalmente as instruções são executadas na ordem em que aparecem no programa. Porém, isso permite apenas a criação de programas muito simples. 

Imagine que tenhamos por exemplo uma matriz com centenas de valores. Para processar cada item dessa matriz, precisamos executar centenas de instruções. Se a instrução for a mesma para todos os itens da matriz, podemos facilitar nossa vida criando um programa bem mais simples se colocarmos essa instrução dentro de um {\it laço}, ao invés de ter uma cópia desta mesma instrução para cada item da matriz.

Outro caso em que o controle de fluxo é útil é quando uma instrução é executada em apenas alguns casos. Imagine que tempos um banco de dados com milhões de valores de CPF e queremos imprimir apenas o nome do portador de um certo CPF. Podemos usar uma instrução do tipo {\tt if} que, para cada CPF lido, testa se é igual ao CPF desejado e imprime o nome do portador somente em caso afirmativo.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: if / else

\section{if / else}

Uma instrução do tipo \IF\ executa um bloco de instruções somente se uma dada condição é verdadeira. Opcionalmente pode ser complementada com uma instrução \ELSE, que executa outro bloco caso a dada condição seja falsa.

\begin{itemize}

\item A forma geral de uma instrução \IF\ é a seguinte:

{\tt 
if (<expressão condicional>)                     \\
\{                                               \\
\TAB <bloco executado se a condição for verdadeira>  \\
\}                                               \\
}

\item A forma geral de uma instrução \IF/\ELSE\ é a seguinte:

{\tt 
if (<expressão condicional>)                     \\
\{                                               \\
\TAB <bloco executado se a condição for verdadeira>  \\
\}                                               \\
else                                             \\
\{                                               \\
\TAB <bloco executado se a condição for falsa>   \\
\}                                               \\
}

\item Observe que a expressão condicional só aparece uma vez, junto ao \IF, jamais junto ao \ELSE.

\item A expressão condicional pode ser uma expressão lógica, de comparação, ou uma operação aritmética com inteiros. Nao usar expressões aritméticas com \FLOAT\ ou \DOUBLE.
\item O bloco do \IF\ é executado se a expressão condicional der como resultado \TRUE\ ou diferente de zero.
\item O bloco do \ELSE\ é executado se a expressão condicional der como resultado \FALSE\ ou igual a zero.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: for

\section{for}
\label{sec:for}

Palavra reservada para criar instruções de iteração, ou seja, laços. Um laço é um bloco que é executado várias vezes.

\begin{itemize}

\item A forma geral de uma instrução \FOR\ é a seguinte:

{\tt 
for (<inicialização>; <condição de continuidade>; <incremento>) \\
\{                                                            \\
\TAB <bloco a ser executado várias vezes>                     \\
\}                                                            \\
}

\item Na inicialização, geralmente uma variável de controle é declarada e inicializada.
\item Variável de controle é a que indica quando o laço deve parar.
\item Na condição de continuidade, se testa se o laço deve continuar. Geralmente isso é feito comparando a variável de controle com algum valor.
\item No incremento, a variável de controle é incrementada. Pode também ser decrementada se necessário.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: while

\section{while}
\label{sec:while}

Faz exatamente o mesmo que o \FOR, ou seja, serve para criar laços. A diferença está na sintaxe.

\begin{itemize}

\item A forma geral de uma instrução \WHILE\ é a seguinte:

{\tt 
<inicialização>;                                              \\ 
while (<condição de continuidade>)                            \\
\{                                                            \\
\TAB <bloco a ser executado várias vezes>                     \\
\TAB <incremento>;                                            \\
\}                                                            \\
}

\item A inicialização, condição de continuidade e incremento funcionam exatamente da mesma maneira que no \FOR, conforme explicado na Seção~\ref{sec:for}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Capítulo: Indentação
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Indentação}

Indentação é a maneira como avançamos ou recuamos as instruções no texto do código fonte para facilitar o entendimento. A linguagem C ignora completamente a indentação. Porém, para o programador, enquanto um código mal indentado pode aparecer completamente ilegível, o mesmo código bem indentado costuma aparecer claro e compreensível.

Observe o código abaixo: 

\begin{lstlisting}
#include <stdio.h> 
int main (void){long int val=1;for(int n=1; 
n<=8;n++){val=val*n;}printf("val = %ld\n",val);}
\end{lstlisting}

Esse código possui exatamente as mesmas instruções que o código a seguir. A única diferença está na indentação. Observe como o código abaixo é mais legível:

\begin{lstlisting}
#include <stdio.h>
int main (void)
{
  long int val = 1;
  for (int n = 1; n <= 8; n++)
  {
    val = val * n; 
  }
  printf("val = %ld\n", val);
}
\end{lstlisting}

\pagebreak

Em C, {\it bloco} se refere a linhas de código entre chaves. Abrimos um novo bloco de código quando declaramos uma função, quando criamos uma instrução de laço com \FOR\ ou \WHILE, ou uma instrução de controle de fluxo com \IF\ ou \SWITCH.
Para se indentar um código em C como no exemplo acima, siga as instruções a seguir:

\begin{itemize}
\item A chave que abre um bloco fica abaixo da primeira letra da instrução que abre o bloco.
\item Cada vez que se abre uma chave, avançar 4 espaços. Cada vez que se fecha uma chave, recuar 4 espaços.
\item A chave que fecha um bloco fica exatamente abaixo da chave que abre o bloco.
\item Cada vez que se abre uma chave, pular uma linha para que a primeira instrução do bloco fique na linha seguinte à da chave.
\end{itemize}

Todo código deve ser indentado corretamente, tanto código escrito em papel quanto em arquivos digitais.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Capítulo: Entrada e saída
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Entrada e saída}

Entrada e saída se refere à comunicação do programa, tanto com o usuário quanto com arquivos em disco. 
Duas funções que podem ser usadas para fazer entrada e saída com o usuário pelo console são \PRINTF\ e \SCANF. 
Para fazer entrada e saída com arquivos, pode-se usar \FPRINTF\ e \FSCANF. 
Para usar qualquer uma dessas funções, adicionar a seguinte linha ao início do código:

\begin{lstlisting}
#include <stdio.h> 
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: printf

\section{printf}
\label{sec:printf}

\PRINTF\ não é uma palavra reservada como \WHILE, e sim uma função. \PRINTF\ espera como primeiro parâmetro uma string, como nos exemplos abaixo.

\begin{lstlisting}
printf("Hello world\n");
printf("bom dia");
printf("Pressione enter para continuar...\n");
\end{lstlisting}

Observe que strings ficam entre aspas duplas. Ao final de algumas das strings acima está o caractere especial '\textbackslash n'. Esse caractere representa um pulo para a linha seguinte. Sempre adicionar esse caractere ao final quando a string contiver uma mensagem que deve aparecer isolada em uma linha. 


\begin{table}
\centering
  \begin{tabular}{|l|l|l|}
    \hline
        Caractere               & Valor ASCII & Representação \\
    \hline
        Pula linha              & 10          & \verb|\n|     \\
        Tabulação               & 9           & \verb|\t|     \\
        {\it Beep}              & 7           & \verb|\a|     \\
        {\it Backslash}         & 92          & \verb|\\|     \\
        Aspas duplas            & 34          & \verb|\"|     \\
        Símbolo de percentagem  & 37          & \verb|%%|     \\
    \hline
  \end{tabular}
  \caption{Caracteres especiais do C}
  \label{tab:chars}
\end{table}


Além do pulo de linha, existem outros caracteres especiais que \PRINTF\ reconhece, como pode ser visto na Tabela~\ref{tab:chars}

\pagebreak

Para ser mais versátil, \PRINTF\ pode imprimir valores de expressões no meio da mensagem. Para isso é necessário colocar na string um especificador de formato no ponto em que o valor deve aparecer, e adicionar como parâmetro a expressão a ser impressa. Especificadores de formato são precedidos pelo símbolo \%\ e servem para definir como interpretar o valor da expressão, ou seja, se é um valor inteiro, real, caractere etc. Observe o exemplo abaixo.

\begin{lstlisting}
printf("Um inteiro ocupa %d bytes\n", sizeof(int));
printf("PI vale %f\n", 3.141592653589793238462);
\end{lstlisting}

Cada uma das strings possui um especificador de formato. A primeira possui um {\tt \%d} 
para imprimir um número inteiro e a segunda possui um {\tt \%f}
para imprimir um número real.
A saída do exemplo acima será a seguinte:\\
\\
{\tt
Um inteiro ocupa 4 bytes\\
PI vale 3.141593\\
}

Por padrão o {\tt \%f} imprime o número real com seis casas decimais, mas esse comportamento pode ser modificado colocando logo depois do símbolo {\tt \%} um ponto seguido do número de casas decimais desejado, como a seguir.

\begin{lstlisting}
printf("PI vale %.10f\n", 3.141592653589793238462);
\end{lstlisting}

cuja saída será\\
\\
{\tt
PI vale 3.1415926536\\
}

O formato de números inteiros também pode ser modificado. Colocando um número {\tt n} de dígitos entre o {\tt \%} e o {\tt d}, fará cada inteiro ocupar {\tt n} espaços. Isso é útil para se imprimir tabelas onde o dígito menos significativo deve ficar alinhado à direita. Para completar o inteiro com zeros à esquerda, colocar um zero entre o {\tt \%} e o número de dígitos completará o número impresso com zeros à esquerda até que ocupe o tamanho desejado. Observe os exemplos abaixo e compare suas saídas.

\pagebreak

\begin{lstlisting}
printf("Um inteiro ocupa %d bytes\n", sizeof(int));
printf("Um inteiro ocupa %6d bytes\n", sizeof(int));
printf("Um inteiro ocupa %06d bytes\n", sizeof(int));
\end{lstlisting}

terão como saída respectivamente

\begin{verbatim}
Um inteiro ocupa 4 bytes
Um inteiro ocupa      4 bytes
Um inteiro ocupa 000004 bytes
\end{verbatim}


\begin{table}
\centering
  \begin{tabular}{|l|l|l|}
    \hline
        Saída                      & Especificador & Exemplo            \\
    \hline
        Inteiro decimal                      & \%d           & 45                 \\
        Inteiro decimal \LONGINT             & \%ld          & 12345678901234     \\
        Inteiro hexadecimal                  & \%x           & f3 ou F3           \\
                                             & \%X           & f3 ou F3           \\
        Número real \FLOAT                   & \%f           & 3.141593           \\
        Número real \DOUBLE                  & \%lf          & 3.141593           \\
        Número real em notação científica    & \%e           & 1.000000e+09       \\
                                             & \%E           & 1.000000E+09       \\
        Caractere                            & \%c           & a                  \\
        String                               & \%s           & Hello              \\
        Endereço de ponteiro                 & \%p           & 0x7fffec2e33a8     \\
    \hline
  \end{tabular}
  \caption{Especificadores de formato do C}
  \label{tab:format}
\end{table}

Em uma mesma string pode haver vários especificadores de formato, bastando que, para cada um dos especificadores, deve haver um valor correspondente como parâmetro. Observe o exemplo abaixo. Existem dois especificadores de formato. O primeiro será substituído pelo valor de {\tt val1} e o segundo, pelo valor de {\tt val2}.

\begin{lstlisting}
int val1 = 33;
float val2 = 1.23;
printf("A variavel inteira vale %d e a variavel real vale %f\n", val1, val2);
\end{lstlisting}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: scanf

\section{scanf}
\label{sec:scanf}

A chamada a \SCANF\ é semelhante à chamada ao \PRINTF. O primeiro parâmetro também é uma string, mas deve possuir um especificador de formato. Os demais parãmetros são os endereços das posições de memória onde os dados serão gravados. É recomendável porém usar uma chamada \SCANF\ para cada valor a ser lido. Para passar o endereço de memória, é necessário preceder a variável pelo símbolo {\tt \%}.

\begin{lstlisting}
int i;
scanf("%d", &i);
float x;
scanf("%f", &x);
char letra;
scanf("%c", &letra);
\end{lstlisting}

\begin{itemize}

\item \SCANF\ retorna o número de valores lidos com sucesso. Idealmente deve-se usar esse valor para testar se a leitura foi bem sucedida.

\item Segue um exemplo de código com \SCANF.

\begin{lstlisting}
#include <stdio.h> 
#include <cstdlib> 
int main (void)
{
  int result;
  float userfloat;
  printf("Digite um numero real:\n");
  result = scanf("%f", &userfloat);
  printf("result = %d, real digitado = %f\n", result, userfloat);
  system("pause");
}
\end{lstlisting}

\item No exemplo acima, {\tt userfloat} armazena o real digitado pelo usuário. A variável {\tt result} será igual a 1 caso a leitura seja bem sucedida, e 0 caso contrário.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: sscanf

\section{sscanf}
\label{sec:sscanf}

\SCANF\ pode não funcionar corretamente quando o usuário digita valores de tipos diferentes do esperado. Uma maneira de contornar isso é armazenando a string em uma variável intermediária antes de fazer a leitura. Nesse caso, a leitura é feita com \SSCANF, uma versão alternativa de \SCANF\ que lê dados de strings.

\begin{lstlisting}
#include <stdio.h> 
#include <cstdlib> 
int main (void)
{
  int result;
  float userfloat;
  char line[256];
  printf("Digite um numero real:\n");
  gets(line);
  result = sscanf(line, "%f", &userfloat);
  printf("result = %d, real digitado = %f\n", result, userfloat);
  system("pause");
}
\end{lstlisting}

\begin{itemize}

\item No exemplo acima, podemos observar uma nova variável chamada {\tt line}, que armazenará o texto digitado pelo usuário. \GETS\ lê o texto digitado e o armazena em {\tt line}, que é passado como parâmetro para \SSCANF. As demais partes do código permanecem como no exemplo da Seção~\ref{sec:scanf}.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: fscanf

\section{fscanf}
\label{sec:fscanf}

\FSCANF é uma função que pode ser usada para leitura de dados de arquivos. Recebe um parâmetro a mais que \SCANF: o ponteiro para o arqivo a ser lido.

\begin{itemize}

\item Para obter o ponteiro para o arquivo, usar a função \FOPEN. No exemplo abaixo, {\tt fp} é a variável que armazenará o ponteiro para o arquivo. O primeiro parâmetro é uma string que contém o nome do arquivo a ser aberto. Neste exemplo é {\tt arquivo.txt} mas poderia ser qualquer outro. O segundo parâmetro indica o tipo de acesso desejado, ou seja, leitura ou escrita. Nesse caso contém uma letra {\tt r} para indicar que o arqivo será aberto para leitura. Usar a letra {\tt w} para escrita. \FOPEN\ retorna zero em caso de erro, ou seja, se o arquivo não existir ou se não houver permissão para o acesso desejado.

\begin{lstlisting}
FILE* fp = fopen("arquivo.txt", "r");
\end{lstlisting}

\item Uma maneira de testar se o arquivo foi aberto corretamente é mostrada a sqguir. Uma mensagem mais esclarecedora para o usuário, e portanto mais útil, pode incluir o nome do arquivo.

\begin{lstlisting}
  if (fp == 0)
  {
    printf("Erro ao abrir arquivo\n");
    return 1;
  }
\end{lstlisting}


\item Uma vez que o arquivo esteja aberto, chamar \FSCANF\ com o ponteiro retornado por \FOPEN\ como primeiro parâmetro. Como \SCANF, recebe também uma string com o especificador de formato, e a variável onde o valor lido deve ser armazenado. Essa variável deve ser passada por referência, ou seja, é necessário usar o símbolo {\tt \&} antes do identificador da variável para indicar que é passado seu endereço como parâmetro.

\begin{lstlisting}
int i;
fscanf(fp, "%d", &i);
float x;
fscanf(fp, "%f", &x);
char letra;
fscanf(fp, "%c", &letra);
\end{lstlisting}

\item Segue um programa exemplo que lê dois números inteiros de um arquivo. Cada número deve estar em uma linha diferente no arquivo.

\begin{lstlisting}
#include <stdio.h> 
int main (void)
{
  int a, b;
  FILE* fp = fopen("arquivo.txt", "r");
  if (fp == 0)
  {
    printf("Erro ao abrir arquivo\n");
    return 1;
  }
  fscanf(fp, "%d", &a);
  printf("Valor de a = %d\n", a);
  fscanf(fp, "%d", &b);
  printf("Valor de b = %d\n", b);
  fclose(fp);
}
\end{lstlisting}

\item Abaixo está uma versão alternativa que usa \FGETS\ para ler cada linha do arquivo por completo antes de tentar extrair dela o número. Observe que a função \FGETS\ é usada no lugar da \GETS, da Seção~\ref{sec:sscanf}. \

\begin{lstlisting}
#include <stdio.h> 
int main (void)
{
  int MAX_LEN = 256
  int a, b;
  FILE* fp = fopen("arquivo.txt", "r");
  if (fp == 0)
  {
    printf("Erro ao abrir arquivo\n");
    return 1;
  }
  char line[MAX_LEN];
  fgets(line, MAX_LEN, fp);
  sscanf(line, "%d", &a);
  printf("Valor de a = %d\n", a);
  fgets(line, MAX_LEN, fp);
  sscanf(line, "%d", &b);
  printf("Valor de b = %d\n", b);
  fclose(fp);
}
\end{lstlisting}


\item Idealmente, deve-se testar se cada \FSCANF\ e \FGETS\ fez uma leitura bem sucedida, como no trecho de código abaixo. \FGETS\ recebe três parâmetros: um vetor de caracteres ou string, o tamanho máximo da string e o ponteiro para o arquivo. Retorna zero em caso de erro.

\begin{lstlisting}
  char* result1 = fgets(line, MAX_LEN, fp);
  int result2 = sscanf(line, "%d", &n);
  if (result1 != 0 && result2 == 1)
  {
    printf("Valor lido = %d\n", result, n);
  }
  else
  {
    printf("Valor invalido\n");
  }
\end{lstlisting}

\item Ao final do programa, após fazer todas as leituras necessárias, fechar o arquivo com \FCLOSE, como na linha de código a seguir. Isso salva as escritas no arquivo e o libera para que outros programas possam acessá-lo.

\begin{lstlisting}
  fclose(fp);
\end{lstlisting}

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Capítulo: Funções
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Funções}

Funções são blocos de instruções que executam uma certa tarefa. 
Podem receber dados de entrada e retornar dados de saída. 
Podemos dizer que a definição de uma função tem cinco partes: identificador ou nome, tipo de dado de retorno, lista de parâmetros, bloco de instruções e valor de retorno.

\begin{itemize}

\item Uma declaração de função tem a seguinte forma geral:

{\tt
<Tipo de dado> <Identificador> (<Lista de parâmetros>)\\
\{\\
\TAB <Bloco de código>\\
\TAB return <Valor de retorno>;\\
\}\\
}

\item Identificador é o nome através do qual chamamos a função. Alguns identificadores de funções já vistas são por exemplo \PRINTF, \SCANF, \FGETS, \SIN\ e \COS.

\item Tipo de dado de retorno é o tipo de dado que a função retorna. Como já foi visto na Seção~\ref{sec:expr}, uma chamada a uma função é uma expressão elementar, e pode ser usada da mesma maneira que uma variável ou valor de mesmo tipo.

\begin{lstlisting}
  double x = sin(a);
  printf("%f\n", x);
\end{lstlisting}

  Observe que \PRINTF\ imprimirá o valor de tipo \DOUBLE\ retornado pela função \SIN. De maneira alternativa, poderíamos colocar a chamada \SIN\ diretamente como parãmetro de \PRINTF.

\begin{lstlisting}
  printf("%f\n", sin(a));
\end{lstlisting}

\item Lista de parâmetros são os dados de entrada da função. Cada parâmetro é uma variável cujo valor é definido na chamada da função. Cada item da lista tem o mesmo formato de uma declaração de variável, ou seja, é um tipo de dado seguido de um identificador. Se uma função recebe mais de um parâmetro, eles devem ser separados por vírgula.

\item Bloco de código é o código executado quando a função é chamada.

\item Valor de retorno é o valor retornado para a função que fez a chamada. Uma chamada a função pode fazer parte de uma expressão e tem o mesmo efeito que seu valor de retorno.

\end{itemize}

No exemplo abaixo podemos ver uma declaração bem simples de função. Essa função não recebe parâmetros e nem retorna valor. Simplesmente imprime uma mensagem e retorna. Logo após a declaração, vemos um exemplo de função \MAIN\ que a chama.

\begin{lstlisting}
#include <stdio.h>
void cumprimenta(void)
{
  printf("Bom dia");
}

int main(void)
{
  cumprimenta();
}
\end{lstlisting}

Abaixo temos outro exemplo de função que não retorna valores. Essa função recebe um número de tipo \DOUBLE\ e o imprime usando notação científica.

\begin{lstlisting}
#include <stdio.h>
void imprimed(double val)
{
  printf("%.10E", val);
}

int main(void)
{
  imprimed(299792458.0);
  printf("\n");
}
\end{lstlisting}

Vale notar que o tipo de dado de retorno da função não tem relação com os tipos dos parãmetros. Podem ser completamente diferentes como no exemplo abaixo, que recebe \FLOAT\ como entrada e retorna \INT. A expressão {\tt (int) } executa um {\it typecast}, ou seja, uma conversão de tipo. 

\begin{lstlisting}
#include <stdio.h>
int arredonda(float val)
{
  return (int) (val+0.5);
}

int main(void)
{
  printf("Pi eh aproximadamente %d\n", arredonda(3.14159265));
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Passagem de parâmetros por valor

\section{Passagem de parâmetros por valor}

Quando chamamos uma função, os valores dos parãmetros são copiados para as variáveis definidas na lista de parâmetros. Podemos modificar esses valores no interior da função sem que isso tenha efeito fora dela.

\begin{lstlisting}
#include <stdio.h>
int dobra(int n)
{
  n = 2 * n;
  return n;
}

int main(void)
{
  int a = 5;
  int b = dobro(a);
  printf("O dobro de %d eh %d\n", a, b);
}
\end{lstlisting}

O valor de {\tt a} é copiado para o parâmetro {\tt n} da função. {\tt n} recebe 10 mas {\tt a} permanece 5.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Passagem de parâmetros por referência

\section{Passagem de parâmetros por referência}

Esse tipo de passagem de parâmetro é necessário quando a função deve ser capaz de alterar alguma variável fora de seu escopo. Em outras palavras, quando precisamos que a função altere alguma variável da função que a chamou. Um exemplo de passagem de parâmetro por referência é o que fazemos ao chamar \SCANF.

Nesse tipo de passagem de parâmetro, ao invés de passarmos um valor, passamos um ponteiro, ou seja, uma referência à posição de memória que gostaríamos de alterar.

No exemplo abaixo, a função {\tt troca} é implementada. Ela troca os valores de duas variáveis da função que a chamou. Isso só é possível usando passagem de parâmetro por referência.

\begin{lstlisting}
#include <stdio.h>
int troca(int *a, int *b)
{
  int aux = *a;
  *a = *b;
  *b = aux;
}

int main(void)
{
  int a = 5;
  int b = 3
  printf("Antes: x = %d, y = %d\n", x, y);
  troca(&x, &y);
  printf("Depois: x = %d, y = %d\n", x, y);
}
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Capítulo: Vetores
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Vetores}

Vetores são sequências de valores do mesmo tipo referenciados por um mesmo nome. Um elemento específico da sequência é acessado por meio de um índice inteiro não negativo.

Na linguagem C, os vetores começam com o índice zero. Um vetor com {\tt n} posições terá como índices válidos os inteiros de zero a {\tt n-1}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Vetores unidimensionais

\section{Vetores unidimensionais}

Uma declaração de vetor tem o seguinte formato:

\NEWLINE
{\tt
<Tipo de dado> <Identificador> [ <Tamanho> ];
}
\NEWLINE

A expressão elementar abaixo funciona como uma variável comum, podendo ser usada em expressões aritméticas, de comparação, atribuição, ou como parâmetro em chamadas de funções.

\NEWLINE
{\tt
<Identificador> [ <Posição> ]
}
\NEWLINE

Uma atribuição de valor a uma certa posição do vetor, por exemplo, tem o seguinte formato:

\NEWLINE
{\tt
<Identificador> [ <Posição> ] = <Valor>;
}
\NEWLINE

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Matrizes

\section{Matrizes}

Uma matriz é um vetor bidimensional. Sua declaração é semelhante à de um vetor unidimensional.

\NEWLINE
{\tt
<Tipo de dado> <Identificador> [ <Linhas> ][ <Colunas> ];
}
\NEWLINE


Para acessar um item individual de uma matriz, usar o formato abaixo:

\NEWLINE
{\tt
<Identificador> [ <Linha> ][ <Coluna> ]
}
\NEWLINE


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Capítulo: Exercícios
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Exercícios}

\newcounter{iQuest}
\setcounter{iQuest}{0}

\newcommand{\quest}{%
\addtocounter{iQuest}{1}%
\arabic{iQuest}}

\newcommand{\zeraquest}{%
\setcounter{iQuest}{0}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Introdução

\zeraquest

\section{Introdução}

\quest - Crie uma função \MAIN\ vazia.

\NEWLINE
\quest - Crie uma função \MAIN\ e dentro dela declare as seguintes variáveis:

	a) um inteiro chamado {\tt n}.

	b) um real de precisão simples chamado {\tt f}.

	c) um real de precisão dupla chamado {\tt d}.

	d) um caracter chamado {\tt c}.

	e) um inteiro longo chamado {\tt l}.

\NEWLINE
\quest - Em C, as instruções devem ser terminadas com ponto e vírgula. A declaração de uma variável é o primeiro lugar do programa onde a variável aparece e é onde seu tipo de dados é definido. A inicialização é onde algum valor é atribuído a ela pela primeira vez. A declaração e inicialização podem ocorrer na mesma instrução. Por exemplo:
\begin{lstlisting}
	int i = 0;
	float x = 5.2;
	float y = x*x;
\end{lstlisting}
Crie uma função \MAIN\ e dentro dela declare e inicialize na mesma instrução:

	a) um inteiro chamado {\tt val}.

	b) um real de precisao simples chamado {\tt x}.

	c) um real de precisão dupla chamado {\tt xd}.

	d) um caracter chamado {\tt tiny}.

	e) um inteiro longo chamado {\tt huge}.

\NEWLINE
\quest - Crie uma função \MAIN\ que faz o mesmo que na questão anterior e em seguida, para cada variável, imprime uma mensagem com seu nome, a palavra "vale", e seu valor. Para uma variável chamada pipoca, por exemplo:

	{\tt pipoca vale 3.141592}

\NEWLINE
\quest - Crie uma função \MAIN\ que faz o mesmo que na questão anterior, porém, ao invés de declarar variáveis, declare constantes.

\NEWLINE
\quest - Crie uma função \MAIN\ e dentro dela declare e inicialize na mesma instrução cinco variáveis inteiras. Para inicializá-las use expressões com três operadores aritméticos cada. Na mesma linha, coloque em um comentário o resultado da expressão. Por exemplo:
\begin{lstlisting}
	int i = 5 + 2 * 3 * 4; // 29
\end{lstlisting}

\NEWLINE
\quest - Crie uma função \MAIN\ e dentro dela declare e inicialize na mesma instrução cinco variáveis inteiras. Para inicializá-las use expressões com cinco operadores aritméticos cada. Na mesma linha, coloque em um comentário o resultado da expressão.

\NEWLINE
\quest - Crie uma função \MAIN\ e dentro dela declare e inicialize na mesma instrução cinco variáveis reais de precisão dupla. Para inicializá-las use expressões com dois operadores aritméticos e uma chamada a função em cada expressão. Na mesma linha, coloque em um comentário o resultado da expressão.

\NEWLINE
\quest - Crie uma função \MAIN\ e dentro dela declare e inicialize na mesma instrução cinco variáveis reais de precisão simples. Para inicializá-las use expressões com três operadores aritméticos cada. Na mesma linha, coloque em um comentário o resultado da expressão.

\NEWLINE
\quest - Crie uma função \MAIN\ que imprime a mensagem \verb|"Hello\n"|.

\NEWLINE
\quest - Crie uma função \MAIN\ que imprime a mensagem \verb|"Hello\n"| e em seguida chama \verb|system("pause")|.

\NEWLINE
\quest - O que acontece quando:

	a) atribuímos um valor \INT\ a uma variável \FLOAT?

	b) atribuímos um valor \FLOAT\ a uma variável \INT?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Controle de fluxo

\zeraquest

\section{Controle de fluxo}

\quest - Crie uma função \MAIN\ que imprime todos os inteiros de 1 a 100 com apenas uma instrução com \PRINTF. Use:

	a) um laço com a palavra reservada \WHILE.

	b) um laço com a palavra reservada \FOR.

\NEWLINE
\quest – Seja n um inteiro entre 1 e 1000. Crie uma função \MAIN\ com um laço ({\tt for} ou {\tt while}) que imprime uma mensagem \verb|"%d modulo 2 vale %d"| para cada {\tt n} entre 1 e 1000. No lugar do primeiro \%d deve aparecer o valor de {\tt n}, e no lugar do segundo \%d, o valor de {\tt n} modulo 2. O operador módulo, representado por \%, retorna o resto da divisão de um número por outro número. Por exemplo, 12 \% 10 retorna 2.

\NEWLINE
	Resposta:

\begin{lstlisting}
int main(void)
{
    for(int i = 1; i <= 1000; i++)
    {
        printf("\%d modulo 2 vale \%d\n", i, i \% 2);
    }
}
\end{lstlisting}
\NEWLINE
\quest – Seja n um inteiro entre 1 e 1000. Crie uma função \MAIN\ com um laço (for ou while) que imprime uma mensagem \verb|"%d eh par"| se {\tt n} for par, ou \verb|"%d eh impar"| se {\tt n} for impar, para cada n entre 1 e 1000. No lugar do primeiro \verb|%d| deve aparecer o valor de {\tt n}. Usar if para testar se o módulo de {\tt n} por 2 vale 0, o que indica que {\tt n} é par, ou 1, o que indica que {\tt n} é ímpar. Observe que operador de comparação que testa igualdade em C é o {\tt ==}, diferente do operador de atribuição {\tt =}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Funções

\zeraquest

\section{Funções}

\quest - Crie uma função chamada {\tt alo} que não recebe parâmetros nem retorna valores, apenas imprime a mensagem \verb|"hello world"|.
	Resposta:
\begin{lstlisting}
	void alo(void)
	{
		printf("hello world\n");
	}
\end{lstlisting}
\NEWLINE
\quest – Crie uma função \MAIN\ que simplesmente chama a função {\tt alo}.

\NEWLINE
\quest - Crie uma função de tipo \VOID\ chamada {\tt preguica}, que não recebe parâmetros e não faz nada.
\NEWLINE
\quest – Crie uma função \MAIN\ que simplesmente chama a função {\tt preguica}.

\NEWLINE
\quest - Crie uma função chamada {\tt imprimeInt} que recebe um parâmetro inteiro, mas não retorna valores, apenas imprime a mensagem \verb|"valor inteiro igual a "| seguida do valor do parâmetro recebido.

\NEWLINE
\quest – Crie uma função \MAIN\ que simplesmente chama a função {\tt imprimeInt}. Lembre-se de fornecer como parâmetro algum valor inteiro.

\NEWLINE
\quest - Crie uma função chamada {\tt duzia} que recebe um parâmetro real de precisão simples e retorna 12 vezes seu valor.
	Resposta:
\begin{lstlisting}
	float duzia(float x)
	{
		return 12*x;
	}
\end{lstlisting}
\NEWLINE
\quest – Crie uma função \MAIN\ que simplesmente chama a função {\tt duzia}. Lembre-se de fornecer como parâmetro algum valor de tipo \FLOAT. Salve o resultado em uma variável e imprima o resultado.

\NEWLINE
\quest - Crie uma função de tipo \INT\ chamada {\tt triplo}, que recebe um parâmetro inteiro e retorna três vezes seu valor.
\NEWLINE
\quest – Crie uma função \MAIN\ que chama a função {\tt triplo}, salva o valor retornado em uma variável e em seguida o imprime.

\NEWLINE
\quest - Crie uma função de tipo \INT\ chamada \verb|eh_par|, que recebe um parâmetro inteiro e retorna 1 (um) caso o inteiro seja par, e 0 (zero) caso contrário.

\NEWLINE
\quest - Crie uma função de tipo \VOID\ chamada \verb|imprime_float|, que recebe um parâmetro de tipo float e imprime a mensagem:

\verb|"o valor da variavel real eh %f\n"|
\\
substituindo o \verb|%f| pelo valor do parâmetro.



\NEWLINE
\quest - Crie uma funcão de tipo \FLOAT\ chamada \verb|circunferencia|, que recebe um parâmetro de tipo \FLOAT\ igual ao raio de um círculo e retorna o comprimento de sua circunferência.

\NEWLINE
\quest - Crie uma funcão de tipo \FLOAT\ chamada \verb|area_circulo|, que recebe um parâmetro de tipo \FLOAT\ igual ao raio de um círculo e retorna seu raio.

\NEWLINE
\quest - Crie uma funcão de tipo \FLOAT\ chamada \verb|volume_esfera|, que recebe um parâmetro de tipo \FLOAT\ igual ao raio de uma esfera e retorna seu volume.

\NEWLINE
\quest - Crie uma funcão de tipo \INT\ chamada \verb|somatoria|, que recebe um parâmetro de tipo \INT\ chamado {\tt n} e retorna a soma dos inteiros de 1 a {\tt n}.

\NEWLINE
\quest - Crie uma função chamada {\tt fatorial} que recebe um parâmetro inteiro e retorna seu fatorial.

	a) implemente a função usando um laço while.

	b) implemente a função usando um laço for.

	c) implemente a função usando uma chamada a ela mesma. Para isso, use a definição recursiva de fatorial:

		se {\tt n == 0} ({\tt ==} é operador de comparação) 

então {\tt fatorial(n) = 1}

		senão {\tt fatorial(n) = n * fatorial(n-1)}

\NEWLINE
\quest - Crie uma funcão de tipo \INT\ chamada {\tt somatoria}, que recebe um parâmetro de tipo \INT\ chamado {\tt n} e retorna a soma dos inteiros de 1 a {\tt n}.


\NEWLINE
\quest - Crie uma funcão de tipo \DOUBLE\ chamada {\tt norma}, que recebe dois parâmetros de tipo \DOUBLE\ chamados {\tt a} e {\tt b}, e retorna a norma do vetor (a,b).


\NEWLINE
\quest - Crie uma função chamada {\tt pg3}, que retorna o terceiro termo de uma progressão geométrica. A função recebe dois parâmetros inteiros, o primeiro parâmetro é o primeiro termo da pg; o segundo é sua razão.

\NEWLINE
\quest - Crie uma função chamada {\tt pg}, que retorna o n-ésimo termo de uma progressão geométrica. A função recebe três parâmetros inteiros, o primeiro parâmetro é o primeiro termo da pg; o segundo é sua razão, o terceiro é o {\tt n}.

\NEWLINE
\quest -

a) Crie uma função de tipo \VOID\ chamada {\tt swap} que recebe dois parâmetros inteiros por referência e troca seus valores.

b) Crie uma função  \MAIN\ e dentro dela declare e inicialize duas variáveis inteiras. Imprima seus valores, chame a função {\tt swap} passando-as por referência e imprima novamente, para testar se os valores foram realmente trocados.

\NEWLINE
\quest - Crie uma funcão de tipo \DOUBLE\ chamada {\tt delta}, que recebe três parâmetros de tipo \DOUBLE\ chamados {\tt a}, {\tt b} e {\tt c}, e retorna o valor de delta, ou seja, b*b – 4.0*a*c.

\NEWLINE
\quest – Crie uma função de tipo \INT\ chamada {\tt baskara}. Ela recebe por valor três parâmetros de tipo double chamados {\tt a}, {\tt b} e {\tt c}, representando os coeficientes de uma equação de segundo grau igual a a*x*x + b*x + c. Recebe ainda dois parâmetros por referência, chamados {\tt x1} e {\tt x2}, onde armazenará as raízes encontradas. Ela retorna o número de raízes reais da equação, ou seja, pode retornar 0 (zero), 1 (um) ou 2 (dois). Usar a função  delta da questâo anterior para testar quantas raízes a equação possui.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Entrada e saída

\zeraquest

\section{Entrada e saída}


\NEWLINE
\quest - Crie uma funcão \MAIN\ e dentro dela:

a) imprima a mensagem \verb|"Favor digitar um valor inteiro \n"|.

b) declare uma variável inteira chamada {\tt i}.

c) use \SCANF\ para ler o inteiro digitado pelo usuário e salvá-lo na variável {\tt i}.

d) imprima a mensagem \verb|"Voce digitou "| seguida do valor digitado e \verb|"\n"|.

e) chame \verb|system("pause")|.

\NEWLINE
\quest - Crie uma funcão \MAIN\ e dentro dela:

a) imprima a mensagem \verb|"Favor digitar um valor inteiro\n"|.

b) declare as variáveis inteiras {\tt i} e {\tt result}.

c) use \SCANF\ para ler o inteiro digitado pelo usuário e salvá-lo na variável {\tt i}. Armazene o valor de retorno de \SCANF\ em {\tt result}.

d) caso o valor de {\tt result} seja igual a 1 (um), imprima a mensagem \verb|Voce digitou "| seguida do valor digitado e \verb|"\n"|.

e) caso contrário, imprima a mensagem \verb|"Eu pedi para digitar um inteiro!\n"|.

f) chame \verb|system("pause")|.

\NEWLINE
\quest - Crie uma funcão \MAIN\ e dentro dela:

a) solicite ao usuário que forneça dois valores reais e armazene-os em duas variáveis chamadas {\tt a} e {\tt b}.

b) para cada variável lida, se a leitura foi bem sucedida imprima o valor lido. Caso contrário imprima uma mensagem de erro e finalize o programa.

c) imprima mensagens indicando o valor da soma, do produto, da diferença, da razão entre {\tt a} e {\tt b}, norma do vetor (a,b) e o valor de {\tt a} elevado a {\tt b}.

\NEWLINE
\quest - Crie uma funcão \MAIN\ e dentro dela:

a) solicite ao usuário que forneça três valores reais e armazene-os em três variáveis chamadas {\tt a}, {\tt b} e {\tt c}.

b) para cada variável lida, se a leitura foi bem sucedida imprima o valor lido. Caso contrário imprima uma mensagem de erro e finalize o programa.

c) imprima mensagens indicando o valor das raízes da equação de segundo grau igual a a*x*x + b*x + c. Usar as funções das questões {\tt baskara} e {\tt delta} criadas anteriormente.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: Vetores

\zeraquest

\section{Vetores}


\NEWLINE
\quest - Crie uma funcão \MAIN:

a) antes dela defina \verb|TAM_MAX| como sendo 10 (dez).

b) dentro dela declare um vetor de inteiros chamado {\tt vet}, com tamanho máximo igual \verb|TAM_MAX|.

c) declare uma variável inteira chamada {\tt tamanho}, para armazenar o tamanho ocupado desse vetor. Inicialize-a com zero.

d) crie um laço \FOR\ que, a cada passo, solicita ao usuário que insira valores para cada posição do vetor, lê e armazena o dado digitado.

e) em caso de sucesso do \SCANF, incremente {\tt tamanho} e continue. Em caso de erro, interrompa o laço com \BREAK.

f) depois do laço, imprima o tamanho ocupado do vetor. Note que o tamanho ocupado pode ser diferente do tamanho máximo \verb|TAM_MAX|.

g) imprima o conteúdo de cada uma das posições do vetor usando a seguinte mensagem: \verb|vet[%d] = %d\n"| substituindo o primeiro \verb|%d| pela posição, e o segundo pelo conteúdo.

\NEWLINE
\quest - Crie uma funcão \MAIN\ e dentro dela, declare um vetor de reais chamado {\tt numeros}. Seu tamanho máximo é definido por uma macro chamada \verb|TAM_MAX|, que vale 10 (dez). Em seguida, abra um arquivo chamado {\tt input.txt} cujo conteúdo é um valor real em cada linha. Use \FSCANF\ para ler esse arquivo e armazenar os valores no vetor {\tt numeros}, e o tamanho ocupado do vetor na variável inteira chamada {\tt tamanho}. Seu programa deve funcionar para qualquer tamanho de entrada, inclusive para arquivos com mais de dez valores. Nesse caso, o vetor ficará completamente ocupado e o valor de tamanho será 10.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Capítulo: Exemplos de programas
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Exemplos de programas}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: pause.cpp

\section{pause.cpp}

\lstinputlisting[caption=series.cpp]{src/pause.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: ascii.cpp

\section{ascii.cpp}

\lstinputlisting[caption=ascii.cpp]{src/ascii.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: dado.cpp

\section{dado.cpp}

\lstinputlisting[caption=dado.cpp]{src/dado.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: primos.cpp

\section{primos.cpp}

\lstinputlisting[caption=series.cpp]{src/primos.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: series.cpp

\section{series.cpp}

\lstinputlisting[caption=series.cpp]{src/series.cpp}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: generate.cpp

\section{generate.cpp}

\lstinputlisting[caption=generate.cpp]{src/generate.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Seção: ordena.cpp

\section{ordena.cpp}

\lstinputlisting[caption=ordena.cpp]{src/ordena.cpp}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Apêndice: Tabela ASCII
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix
\chapter{Tabela ASCII}

{\tt\small

\begin{tabular}{|lll|lll|lll|lll|}

  Dec &   Hex & Char &  Dec &   Hex & Char &  Dec &   Hex & Char &  Dec &   Hex & Char \\

    0 &  0x00 &  NUL &   32 &  0x20 &      &   64 &  0x40 &    @ &   96 &  0x60 &    ` \\
    1 &  0x01 &  STX &   33 &  0x21 &    ! &   65 &  0x41 &    A &   97 &  0x61 &    a \\
    2 &  0x02 &  SOT &   34 &  0x22 &    " &   66 &  0x42 &    B &   98 &  0x62 &    b \\
    3 &  0x03 &  ETX &   35 &  0x23 &   \# &   67 &  0x43 &    C &   99 &  0x63 &    c \\
    4 &  0x04 &  EOT &   36 &  0x24 &   \$ &   68 &  0x44 &    D &  100 &  0x64 &    d \\
    5 &  0x05 &  ENQ &   37 &  0x25 &   \% &   69 &  0x45 &    E &  101 &  0x65 &    e \\
    6 &  0x06 &  ACK &   38 &  0x26 &   \& &   70 &  0x46 &    F &  102 &  0x66 &    f \\
    7 &  0x07 &  BEL &   39 &  0x27 &    ' &   71 &  0x47 &    G &  103 &  0x67 &    g \\
    8 &  0x08 &   BS &   40 &  0x28 &    ( &   72 &  0x48 &    H &  104 &  0x68 &    h \\
    9 &  0x09 &   HT &   41 &  0x29 &    ) &   73 &  0x49 &    I &  105 &  0x69 &    i \\
   10 &  0x0A &   LF &   42 &  0x2A &    * &   74 &  0x4A &    J &  106 &  0x6A &    j \\
   11 &  0x0B &   VT &   43 &  0x2B &    + &   75 &  0x4B &    K &  107 &  0x6B &    k \\
   12 &  0x0C &   FF &   44 &  0x2C &    , &   76 &  0x4C &    L &  108 &  0x6C &    l \\
   13 &  0x0D &   CR &   45 &  0x2D &    - &   77 &  0x4D &    M &  109 &  0x6D &    m \\
   14 &  0x0E &   SO &   46 &  0x2E &    . &   78 &  0x4E &    N &  110 &  0x6E &    n \\
   15 &  0x0F &   SI &   47 &  0x2F &    / &   79 &  0x4F &    O &  111 &  0x6F &    o \\
   16 &  0x10 &  DLE &   48 &  0x30 &    0 &   80 &  0x50 &    P &  112 &  0x70 &    p \\
   17 &  0x11 &  DC1 &   49 &  0x31 &    1 &   81 &  0x51 &    Q &  113 &  0x71 &    q \\
   18 &  0x12 &  DC2 &   50 &  0x32 &    2 &   82 &  0x52 &    R &  114 &  0x72 &    r \\
   19 &  0x13 &  DC3 &   51 &  0x33 &    3 &   83 &  0x53 &    S &  115 &  0x73 &    s \\
   20 &  0x14 &  DC4 &   52 &  0x34 &    4 &   84 &  0x54 &    T &  116 &  0x74 &    t \\
   21 &  0x15 &  NAK &   53 &  0x35 &    5 &   85 &  0x55 &    U &  117 &  0x75 &    u \\
   22 &  0x16 &  SYN &   54 &  0x36 &    6 &   86 &  0x56 &    V &  118 &  0x76 &    v \\
   23 &  0x17 &  ETB &   55 &  0x37 &    7 &   87 &  0x57 &    W &  119 &  0x77 &    w \\
   24 &  0x18 &  CAN &   56 &  0x38 &    8 &   88 &  0x58 &    X &  120 &  0x78 &    x \\
   25 &  0x19 &   EM &   57 &  0x39 &    9 &   89 &  0x59 &    Y &  121 &  0x79 &    y \\
   26 &  0x1A &  SUB &   58 &  0x3A &    : &   90 &  0x5A &    Z &  122 &  0x7A &    z \\
   27 &  0x1B &  ESC &   59 &  0x3B &    ; &   91 &  0x5B &    [ &  123 &  0x7B &   \{ \\
   28 &  0x1C &   FS &   60 &  0x3C &    < &   92 &  0x5C &    \ &  124 &  0x7C &    | \\
   29 &  0x1D &   GS &   61 &  0x3D &    = &   93 &  0x5D &    ] &  125 &  0x7D &   \} \\
   30 &  0x1E &   RS &   62 &  0x3E &    > &   94 &  0x5E & \verb|^| &  126 &  0x7E &    ~ \\
   31 &  0x1F &   US &   63 &  0x3F &    ? &   95 &  0x5F & \verb|_| &  127 &  0x7F & DEL \\

\end{tabular}

}

\end{document}

